

Note: In this problem you must NOT generate any output on your own. Any such solution will be considered as being against the rules and its author will be disqualified. The output of your solution must be generated by the uneditable code provided for you in the solution template.

An important concept in Object-Oriented Programming is the open/closed principle, which means writing code that is open to extension but closed to modification. In other words, new functionality should be added by writing an extension for the existing code rather than modifying it and potentially breaking other code that uses it. This challenge simulates a real-life problem where the open/closed principle can and should be applied.

A Tree class implementing a rooted tree is provided in the editor. It has the following publicly available methods:

getValue(): Returns the value stored in the node.
getColor(): Returns the color of the node.
getDepth(): Returns the depth of the node. Recall that the depth of a node is the number of edges between the node and the tree's root, so the tree's root has depth  and each descendant node's depth is equal to the depth of its parent node .
In this challenge, we treat the internal implementation of the tree as being closed to modification, so we cannot directly modify it; however, as with real-world situations, the implementation is written in such a way that it allows external classes to extend and build upon its functionality. More specifically, it allows objects of the TreeVis class (a Visitor Design Pattern) to visit the tree and traverse the tree structure via the accept method.












class SumInLeavesVisitor extends TreeVis {
private int result = 0;

public int getResult() {
    return result;
}

public void visitNode(TreeNode node) {
}

public void visitLeaf(TreeLeaf leaf) {
    result += leaf.getValue();
}
}

class ProductOfRedNodesVisitor extends TreeVis {
   private long result = 1;
private final int M = 1000000007;

public int getResult() {
    return (int) result;
}

public void visitNode(TreeNode node) {
    if(node.getColor().equals(Color.RED)) {
        result = (result * node.getValue()) % M;
    }
}

public void visitLeaf(TreeLeaf leaf) {
    if(leaf.getColor().equals(Color.RED)) {
        result = (result * leaf.getValue()) % M;
    }
}
}

class FancyVisitor extends TreeVis {
   private int evenDepthNonLeavesSum = 0;
private int greenLeavesSum = 0;

public int getResult() {
    return Math.abs(evenDepthNonLeavesSum - greenLeavesSum);
}

public void visitNode(TreeNode node) {
    if(node.getDepth() % 2 == 0)
        evenDepthNonLeavesSum += node.getValue();
}

public void visitLeaf(TreeLeaf leaf) {
    if(leaf.getColor().equals(Color.GREEN))
        greenLeavesSum += leaf.getValue();
}
}

public class Solution {
  
  private static int nodeValues[];
private static Color nodeColors[];
private static Map<Integer, Set<Integer>> nodesMap = new HashMap<>();

public static Tree solve() {

    Scanner in = new Scanner(System.in);

    int numberOfNodes = in.nextInt();

    nodeValues = new int[numberOfNodes];
    for(int index = 0; index < numberOfNodes; index++) {
        nodeValues[index] = in.nextInt();
    }

    nodeColors = new Color[numberOfNodes];
    for(int index = 0; index < numberOfNodes; index++) {
        nodeColors[index] = (in.nextInt() == 0) ? Color.RED : Color.GREEN;
    }

    Tree rootNode;
    if(numberOfNodes == 1) {
        rootNode = new TreeLeaf(nodeValues[0], nodeColors[0], 0);
    }
    else {
        for(int index = 0; index < (numberOfNodes - 1); index++) {
            int u = in.nextInt();
            int v = in.nextInt();
            Set<Integer> uEdges = nodesMap.get(u);
            if(uEdges == null) {
                uEdges = new HashSet<>();
            }
            uEdges.add(v);
            nodesMap.put(u, uEdges);
            Set<Integer> vEdges = nodesMap.get(v);
            if(vEdges == null) {
                vEdges = new HashSet<>();
            }
            vEdges.add(u);
            nodesMap.put(v, vEdges);
        }

        rootNode = new TreeNode(nodeValues[0], nodeColors[0], 0);
        Set<Integer> rootEdges = nodesMap.get(1);
        Iterator<Integer> rootIterator = rootEdges.iterator();
        while(rootIterator.hasNext()) {
            Integer nodeIdentifier = rootIterator.next();
            nodesMap.get(nodeIdentifier).remove(1);
            createEdge(rootNode, nodeIdentifier);
        }
    }

    return rootNode;
}

private static void createEdge(Tree parentNode, Integer nodeIdentifier) {

    Set<Integer> nodeEdges = nodesMap.get(nodeIdentifier);
    boolean hasChild = false;
    if(nodeEdges != null && !nodeEdges.isEmpty())
        hasChild = true;

    if(hasChild) {
        TreeNode node = new TreeNode(nodeValues[nodeIdentifier - 1], nodeColors[nodeIdentifier - 1], parentNode.getDepth() + 1);
        ((TreeNode) parentNode).addChild(node);
        Iterator<Integer> nodeIterator = nodeEdges.iterator();
        while(nodeIterator.hasNext()) {
            Integer neighborNodeIdentifier = nodeIterator.next();
            nodesMap.get(neighborNodeIdentifier).remove(nodeIdentifier);
            createEdge(node, neighborNodeIdentifier);
        }
    }
    else {
        TreeLeaf leaf = new TreeLeaf(nodeValues[nodeIdentifier - 1], nodeColors[nodeIdentifier - 1], parentNode.getDepth() + 1);
        ((TreeNode) parentNode).addChild(leaf);
    }
}
